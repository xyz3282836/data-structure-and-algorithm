# 数据结构逻辑关系

(K,R) 对R的性质来分：

线性结构

树型结构

图结构

数据道存储结构分为：四种

顺序、链接、索引、散列（哈希）

## 顺序存储

数组

存、读时间复杂度为O(1)

插入、删除时间复杂度O(n)

## 链接存储

比顺序存储高级，解决了顺序存储的缺点

单链表

头结点：自定义信息+头指针

中间结点：元信息+指针

最后结点：元信息+null

## 索引

是顺序存储的一种推广

## 散列-哈希

是索引的一种延伸与扩展



# 线性结构分类

其中顺序访问：栈、队列

目录索引型的：字典、散列-哈希



# 线性表

存储结构上分为顺序表和链表（单链表、双链表、循环链表）

操作上分为线性表（不限制操作），栈（在同一端操作），队列（在两端操作）

单链表：不带头结点和带头结点



# 栈

last in first out

两种实现方式：顺序栈和链式栈

后缀表达式（运用栈）

中缀表达式（小学运算）

递归调用原理



# 队列

First in first out

两种实现方式：顺序队列和链式队列

链式队列往往采用单链表

front rear



# 二叉树

### DFS-深度优先搜索

使用栈

时间代价 O(n)

空间单价 最坏O(n) 最好O(log n)

1. tLR前序序列 前缀
2. LtR中序
3. LRt后序序列 后缀

> 5.2.1-10min

### BSF-广度优先搜索

使用队列

时间代价 O(n)

空间单价 最坏O(n) 最好O(1)

### 二叉树的存储结构：链式

二叉链表和三叉链表

存储密度

### 完全二叉树的顺序存储结构 



# 二叉搜索树-BST

左<根<右

比较良好的检索性能



# 堆

树型结构、二叉树结构

可以用bst理解

左<根<右

建立最小堆过程：

建堆时间效率 O(n)



# Huffman树



# 树

和二叉树区别

层数：0开始

深度：最大层数

高度：最大层数+1

- [x] 森林与二叉树相互转化

森立的遍历

1. 先根序列-类似二叉树前序
2. 后根序列-类似二叉树中序
3. 没有中根序列-无法确定在哪两个子结点之间

先根深度优先搜索

广度优先搜索

> 6.1.2-9min

# 树的链式存储结构



# 图



# 归并排序

递归的代价很大



# 内排序

## 桶序列

数组长度n，记录区间[0,m)

时间代价 𝜽(m+n)

空间代价 𝜽(m+n)

适合m很小



# 索引

把一个关键码与它对应的数据记录的位置相关联的过程

(关键码，指针) 即(key,pointer)

二级索引解决索引文件较大问题

## 线性索引

效率差

## 静态索引

### 1.多分树-isam

多级索引结构

分为主索引、柱面索引、磁道索引

深度可以减少

### 2.B+树-vsam



## 倒排索引

按属性建立索引表成为倒排表

(Attr,ptrlist) 属性，主码

正文文件的倒排

正文索引：词索引、全文索引



# B树

不是binary是balanced，区分bst和b树区别

一种平衡的多分树

m阶B树

1. 每个结点最多m个子结点（边）
2. 除根、叶结点，其他结点至少m/2结点（边）ceil
3. 所有叶结点都在同一层（树高在log(n)）
4. k个子结点的非根结点恰好包含k-1个关键码 P0-Pj K1-Kj P0 < K1 < P1…<Pj
5. 根结点至少两个子结点（边）


2-3树 = 3阶B树

B树应该是>=3阶树

包含N个关键码的B树，假设外部指针在K层，有N+1个外部指针

比如5阶树，一个非根或叶的结点，最多5条边，4个关键码，最少3条边，2个关键码

N+1>=2*([m/2] k-1)

时间代价

空间代价

# B+树

叶结点存储信息，所有关键码出现在叶结点上 

1. 每个结点最多m个子结点（边）
2. 除根、叶结点，其他结点至少m/2结点（边）ceil
3. k个子结点必有k个关键码
4. 根结点至少两个子结点（边）

支持范围查找

# 位索引



# 红黑树

平衡的扩充的满二叉搜索树bst

红黑树称为2-3-4树（4阶B树）